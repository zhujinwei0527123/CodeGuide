---
title: 【付费】第17章：通过三级缓存解决循环依赖
pay: https://articles.zsxq.com/id_w629m13v0hni.html
---

# 【付费】第 17 章：攻无不克，通过三级缓存解决循环依赖

作者：小傅哥
<br/>博客：[https://bugstack.cn](https://bugstack.cn)
<br/>星球：[https://articles.zsxq.com/id_w629m13v0hni.html](https://articles.zsxq.com/id_w629m13v0hni.html)

> 沉淀、分享、成长，让自己和他人都能有所收获！😄

## 一、前言

`嘎哈呀，又不是不能用！`

我经常说业务逻辑的代码实现，就像擦屁屁的纸，`80%`的面积都是保护手的。而那`20%`的核心流程也就仅仅是你说的能用就行，反正每次都洗手呗。

其实想把程序从**能用**实现到**好用**并不容易，这包括你对业务的理解、你对架构的把控、你对细节的实现等等，也包括你是否能做一些列的抽象实现，不至于整个程序随着开发的越多就变的越臃肿不堪。

那么对于编程上的写`好程序的理解`，我通常喜欢用生活中实际的例子来表达，因为有不少前辈的研发大牛都说：“你要面对对象编程”。所以嘞，我可能会用生活中的超市、展台、货架、官渡等来对我的程序开发中的类或者领域服务进行命名和实现，这样抽象化出来的代码逻辑更具有扩展性，也能让新接手的人快速理解并且不至于慌乱的开发。

## 二、目标

按照目前我们实现的 Spring 框架，是可以满足一个基本需求的，但如果你配置了A、B两个Bean对象互相依赖，那么立马会抛出 `java.lang.StackOverflowError`，为什么呢？因为`A创建`时需要依赖`B创建`，而B的创建又依赖于A创建，就这样死循环了。

而这个循环依赖基本也可以说是 Spring 中非常经典的实现了，所要解决的场景主要有以下三种情况：

![](https://bugstack.cn/assets/images/2020/interview/interview-31-1.png)

- 循环依赖主要分为这三种，自身依赖于自身、互相循环依赖、多组循环依赖。
- 但无论循环依赖的数量有多少，循环依赖的本质是一样的。就是你的完整创建依赖于我，而我的完整创建也依赖于你，但我们互相没法解耦，最终导致依赖创建失败。
- 所以需要 Spring 提供了除了构造函数注入和原型注入外的，setter 循环依赖注入解决方案。